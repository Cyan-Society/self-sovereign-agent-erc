# **Lit Protocol PKP Setup for Autonomous Agents: A Step-by-Step Implementation Guide**

## **1\. Executive Summary: The Infrastructure of Autonomy**

The dawn of the autonomous agent economy presents a fundamental paradox in digital asset management. As artificial intelligence evolves from passive chat interfaces to active economic agents capable of executing complex workflows—trading, voting, provisioning infrastructure, and managing portfolios—the traditional models of cryptographic custody have become obsolete. The conventional wallet architecture, predicated on a single private key stored locally or managed via a hardware device, demands a human-in-the-loop for transaction signing. This requirement effectively neuters the "autonomy" of an AI agent, tethering its operation to human availability. Conversely, storing a raw private key in an agent's runtime environment (e.g., a .env file on a cloud server) introduces a catastrophic single point of failure, where the compromise of a single server results in the total, irreversible loss of assets.

Lit Protocol resolves this dichotomy by fundamentally reimagining the concept of a private key. Through the convergence of Multi-Party Computation (MPC), specifically Threshold Secret Sharing (TSS), and Trusted Execution Environments (TEEs), Lit Protocol introduces the **Programmable Key Pair (PKP)**. In this architecture, the private key never exists in a single location. Instead, it is generated and stored as disparate shares across a decentralized network of nodes. These nodes only collaborate to sign a transaction when specific, immutable cryptographic policies—defined as **Lit Actions**—are satisfied.

This report serves as an exhaustive, expert-level implementation guide for architects and engineers deploying autonomous agents using Lit Protocol. It provides a comprehensive analysis of the entire lifecycle, from the theoretical cryptographic underpinnings to the practical execution of Python-based agent workflows on the new Datil mainnet. By leveraging the lit-python-sdk, developers can instantiate agents that possess sovereign identity, manage their own economic resources via Capacity Credits, and execute logic with verifiable security, all without ever exposing a private key to the application layer.

## **2\. Theoretical Framework: Cryptography and Network Topology**

To implement a robust autonomous agent, one must first understand the cryptographic substrate that allows Lit Protocol to function as a decentralized key management network. This infrastructure is not merely a "wallet" but a programmable interface for distributed cryptography.

### **2.1 Multi-Party Computation and Threshold Secret Sharing**

The core innovation of Lit Protocol lies in its utilization of Threshold Secret Sharing (TSS). In a traditional Public Key Infrastructure (PKI) setting, a private key ($d$) is generated by a single entity and used to derive a public key ($Q$). Security relies entirely on keeping $d$ secret.

Lit Protocol employs **Distributed Key Generation (DKG)**. When a PKP is minted, the private key is not created by a single machine. Instead, the nodes of the Lit Network execute a DKG protocol to collectively generate the key. Each node $i$ receives a private key share $s\_i$. The mathematical properties of the curve (typically ECDSA secp256k1 for Ethereum compatibility) allow the public key $Q$ to be derived from the collective shares without ever reconstructing the full private key $d$.

When an agent requests a signature, it does not ask for the key. It requests that the network sign a message ($m$).

1. **Request:** The agent sends $m$ and the target PKP identity to the network.  
2. **Verification:** Each node independently validates whether the agent is authorized to request this signature (e.g., via Auth Methods or Lit Actions).  
3. **Partial Signing:** If authorized, each node $i$ uses its share $s\_i$ to generate a partial signature $\\sigma\_i$.  
4. **Aggregation:** These partial signatures are collected. If a threshold number of shares ($t$ out of $n$) are present, they can be mathematically combined to produce a valid signature $\\sigma$ for the message $m$.2

This process ensures **fault tolerance** and **security**. If the threshold is 20 out of 30 nodes, the network can tolerate the offline status or malicious behavior of up to 10 nodes without compromising the availability or integrity of the key. For an autonomous agent, this means high availability: the agent's ability to transact is not dependent on a single server or hardware wallet.1

### **2.2 Trusted Execution Environments (TEEs)**

While MPC protects the key at rest, **Trusted Execution Environments (TEEs)** protect the logic that authorizes the key's usage. Lit nodes run on hardware that supports AMD SEV-SNP (Secure Encrypted Virtualization \- Secure Nested Paging).

A TEE is a hardware-isolated enclave within a processor. Code running inside the TEE is encrypted in memory. Even the node operator—the person who physically owns the server—cannot inspect the memory, modify the code, or view the data being processed inside the enclave.

* **Attestation:** Each node provides a cryptographic attestation proving it is running the genuine, unmodified Lit Protocol software stack.  
* **Policy Enforcement:** This allows Lit Actions (JavaScript code) to execute securely. When an agent says "Sign this transaction if the price of ETH is under $2000," that logic runs inside the TEE. The node's key share is only used to sign if the logic in the TEE evaluates to true.4

### **2.3 The Programmable Key Pair (PKP) Model**

The PKP serves as the digital identity of the autonomous agent. Crucially, the "root ownership" of this identity is represented as an ERC-721 Non-Fungible Token (NFT) on the Lit blockchain (Chronicle Yellowstone).

| Component | Description | Relevance to Agents |
| :---- | :---- | :---- |
| **PKP NFT** | An ERC-721 token on Chronicle Yellowstone. | Represents the "Owner" of the agent. Can be held by a DAO, a multisig, or another user. |
| **PKP Address** | The ETH address derived from the DKG public key. | The "Wallet Address" that holds assets and interacts with DeFi protocols. |
| **Controller** | The entity holding the NFT. | Can assign permissions, add auth methods, and grant capabilities. |
| **Permissions** | Auth Methods and Scopes attached to the PKP. | Determines *who* or *what* (e.g., a specific Python script) can drive the agent. |

This separation of "Ownership" (the NFT) and "Control" (the Auth Method) is vital. A DAO can own the NFT (and thus the funds), while granting a Python script the ability to sign transactions only within strict limits defined by a Lit Action. If the script behaves badly, the DAO can simply revoke the script's permissions without moving the funds, as the wallet address remains attached to the NFT.1

## **3\. Network Architecture and Environment Setup**

The Lit ecosystem has undergone a significant architectural shift with the introduction of the **Datil** mainnet, superseding the legacy Habanero and Manzano networks. Understanding this topology is critical for correct SDK configuration.

### **3.1 Network Topology: Chronicle Yellowstone and Datil**

The Lit Network is not a single blockchain but a system of nodes that coordinate via a custom EVM rollup called **Chronicle Yellowstone** (built on Arbitrum Orbit).7

* **Chronicle Yellowstone:** This is the coordination layer. It hosts the PKP NFT contracts, the Access Control Logic, and the Capacity Credit ledgers. It uses the tstLPX token for gas fees.  
* **Datil (Mainnet):** The production network for real-world assets. It requires payment via Capacity Credits. The SDK identifier is LIT\_NETWORK.Datil.  
* **Datil-Test (Testnet):** The development environment. It uses tstLPX for testing but holds no real asset value. The SDK identifier is LIT\_NETWORK.DatilTest.8

**Migration Warning:** Developers utilizing documentation referencing "Habanero", "Manzano", or "Cayenne" must update their configurations. These networks are deprecated. The lit-python-sdk v0.1.x and higher are designed for Datil compatibility.8

### **3.2 Prerequisites and Tooling**

The implementation of an autonomous agent requires a specific stack. Because the Lit nodes execute JavaScript/WASM, the client-side SDKs heavily leverage Node.js. The **Python SDK** is a polyglot wrapper that manages a background Node.js process to bridge Python logic with the Lit cryptographic libraries.

**System Requirements:**

* **Python:** Version 3.10 or higher.  
* **Node.js:** Version 19.0.0 or higher (Required for the background process).  
* **OS:** Linux, MacOS, or Windows.  
* **Wallet:** An Ethereum private key (for the "Controller" role) funded with tstLPX tokens.11

**Installation:**

Bash

\# Install the core Lit Python SDK  
pip install lit-python-sdk

\# Optional: Install the Agent Wallet abstraction for higher-level management  
pip install agentWallet-python

11

### **3.3 Funding the Controller Wallet**

To interact with Chronicle Yellowstone (minting PKPs, buying Capacity Credits), the controller wallet must hold tstLPX.

1. **Faucet:** Navigate to the Lit Protocol Faucet (chronicle-yellowstone-faucet.getlit.dev).  
2. **Input:** Enter the EVM address of the controller wallet (the one whose private key will be used in the Python script).  
3. **Verification:** Check the transaction on the Yellowstone Explorer (yellowstone-explorer.litprotocol.com) to confirm receipt of tokens.7

## **4\. Minting the Programmable Identity (PKP)**

The first step in the agent lifecycle is the creation of its identity. This is not merely generating a key pair locally; it is an on-chain event where the Lit Network is instructed to generate a distributed key and assign ownership to the controller.

### **4.1 The Minting Process**

Minting involves two distinct actions that can be combined into a single transaction:

1. **Token Generation:** The PKP NFT is minted on Chronicle Yellowstone.  
2. **Permissioning:** An initial "Auth Method" is assigned to the PKP. This Auth Method defines what credential allows control over the PKP.

For an autonomous agent, the most robust initial Auth Method is the **EthWallet** of the controller. This allows the developer to sign messages proving ownership of the controller wallet to authorize the PKP. Later, this can be restricted to specific Lit Actions.6

### **4.2 Implementation: Minting with Python**

The following code demonstrates how to connect to the Datil-Test network and mint a PKP. It utilizes a **Sign-In with Ethereum (SIWE)** message to generate an Authentication Signature (AuthSig), which serves as the proof of entitlement to mint.

Python

import os  
from lit\_python\_sdk import connect  
from datetime import datetime, timedelta, timezone  
import json

\# 1\. Configuration and Connection  
\# The private key of the human developer or the master controller system.  
CONTROLLER\_PRIVATE\_KEY \= os.getenv("LIT\_CONTROLLER\_PRIVATE\_KEY")

\# Initialize the Lit Client. This spawns the local Node.js server.  
\# The 'lit\_network' parameter is crucial. Use "datil-test" for dev.  
client \= connect()  
client.set\_auth\_token(CONTROLLER\_PRIVATE\_KEY)  
client.new(lit\_network="datil-test", debug=True)  
await client.connect()

print("Connected to Lit Datil-Test Network")

\# 2\. Prepare the Authentication Material (AuthSig)  
\# We need to prove we own the wallet that will own the PKP.  
\# The 'resources' field specifies what this AuthSig is allowed to do.  
\# resourcePrefix "lit-litaction" allows executing actions.  
expiration \= (datetime.now(timezone.utc) \+ timedelta(minutes=10)).strftime("%Y-%m-%dT%H:%M:%SZ")

siwe\_result \= client.create\_siwe\_message(  
    uri="http://localhost:3092",  
    expiration=expiration,  
    resources=\[{  
        "resource": {  
            "resource": "\*",  
            "resourcePrefix": "lit-litaction",  
        },  
        "ability": "lit-action-execution",  
    }\],  
    wallet\_address=client.wallet\_address  
)

\# Generate the signature for the SIWE message  
auth\_sig\_result \= client.generate\_auth\_sig(siwe\_result\["siweMessage"\])  
auth\_sig \= auth\_sig\_result

\# 3\. Mint the PKP  
\# We use the 'mint\_with\_auth' helper.  
\# authMethodType 1 corresponds to 'EthWallet'.  
\# scopes= corresponds to 'SignAnything'.  
print("Minting PKP...")  
mint\_result \= client.mint\_with\_auth(  
    auth\_method={  
        "authMethodType": 1,   
        "accessToken": auth\_sig, \# The AuthSig acts as the access token  
    },  
    scopes=   
)

pkp\_info \= mint\_result\["pkp"\]  
print(f"✅ PKP Minted Successfully\!")  
print(f"Token ID: {pkp\_info\['tokenId'\]}")  
print(f"Public Key: {pkp\_info\['publicKey'\]}")  
print(f"ETH Address: {pkp\_info\['ethAddress'\]}")

6

### **4.3 Understanding Scopes and Permissions**

In the code above, scopes= is used. Lit Protocol defines specific scopes for Auth Methods to limit the blast radius if an Auth Method is compromised.

| Scope ID | Name | Description | Recommended for Agents |
| :---- | :---- | :---- | :---- |
| **0** | NoPermissions | Auth method can exist but do nothing. | Use for staging/paused agents. |
| **1** | SignAnything | Can sign any data (transactions, messages). | **Yes**, for general purpose agents. |
| **2** | PersonalSign | Can only sign EIP-191 messages. | Use for identity/login agents (non-financial). |

**Security Note:** While SignAnything is necessary for DeFi agents (signing complex transactions), it is high-risk. In a production environment, you should transition from using EthWallet as the controller to using a **Lit Action** as the controller, which can programmatically enforce constraints (e.g., "SignAnything, BUT only if the transaction interacts with the Uniswap Router").6

## **5\. The Cognitive Layer: Writing Lit Actions**

If the PKP is the "body" of the agent, the **Lit Action** is its "brain". A Lit Action is a JavaScript function that runs immutably across the decentralized network. It serves as the policy engine that dictates strictly *when* the PKP allows a signature to be generated.

### **5.1 Lit Action Anatomy**

Lit Actions are executed in a constrained V8 runtime environment. They have access to specific global objects injected by the node:

* Lit.Actions: Methods to control the node (e.g., setResponse, signEcdsa, signAndCombineEcdsa).  
* Lit.Auth: Context about who called the action (the authentication context).  
* fetch: Standard HTTP fetch API for making external requests.  
* ethers: The ethers.js library for blockchain interaction.4

### **5.2 Determinism and Consensus**

A critical concept in Lit Actions is **determinism**. Since the code runs on multiple nodes (e.g., 30 nodes), and a threshold (e.g., 20\) must agree to sign, the logic must produce the *exact same result* on all nodes.

* **Safe:** 2 \+ 2, hashing a string, checking if input \> 10\.  
* **Unsafe:** Math.random(), Date.now() (nodes have slightly different clocks).  
* **Risky:** fetch(url). If the API returns a timestamp or dynamic data that changes between the milliseconds it takes for Node A and Node B to call it, consensus will fail.

**Mitigation for fetch:** Use APIs that are idempotent or based on block height. Alternatively, use Lit.Actions.runOnce to designate a single node to fetch the data and broadcast it to the others, though this reduces trust from "Any Trust" to "Trust One" for that specific data point.4

### **5.3 Implementation: A Conditional Signing Action**

The following Lit Action implements a "Weather Derivative Agent". It only signs a transaction if the temperature at a specific location is below 60°F.

**JavaScript Code (Lit Action):**

JavaScript

const litActionCode \= \`  
(async () \=\> {  
  // 1\. Fetch External Data  
  // We use a weather API. Note: In production, ensure the API is robust/versioned.  
  const url \= "https://api.weather.gov/gridpoints/TOP/31,80/forecast";  
    
  try {  
    const resp \= await fetch(url).then((response) \=\> response.json());  
    const temp \= resp.properties.periods.temperature;  
    console.log("Current temperature:", temp);

    // 2\. Define the Policy Logic  
    // Condition: Only sign if the temperature is \< 60 degrees.  
    if (temp \>= 60\) {  
      // Reject the request  
      Lit.Actions.setResponse({ response: "Error: Temperature is too high to execute transaction." });  
      return;  
    }

    // 3\. Execution: Sign the Transaction  
    // 'toSign' and 'publicKey' are passed in via jsParams from Python.  
    // 'sigName' identifies this signature in the response.  
    const sigShare \= await Lit.Actions.signAndCombineEcdsa({  
      toSign: toSign,  
      publicKey: publicKey,  
      sigName: "weather\_agent\_sig"  
    });

    // 4\. Set the success response  
    // The combined signature will be returned to the client.  
    Lit.Actions.setResponse({ response: sigShare });

  } catch (error) {  
    Lit.Actions.setResponse({ response: "Error fetching weather data: " \+ error.message });  
  }  
})();  
\`;

15

### **5.4 Storing Actions on IPFS for Immutability**

While the SDK allows passing the code as a string (as above), this is insecure for autonomous agents. If the Python script is modified by an attacker, the policy changes.

**Best Practice:**

1. Upload the Lit Action JavaScript file to **IPFS**.  
2. Obtain the **IPFS CID** (e.g., QmXyZ...).  
3. When minting or assigning permissions to the PKP, grant the Lit Action Execution capability **strictly** to that IPFS CID.  
4. Now, the agent can only execute that exact, immutable code. No one—not even the owner—can force the PKP to run modified logic without minting a new PKP or updating on-chain permissions.16

## **6\. Authentication and Session Management**

For an autonomous agent to operate continuously, it must be able to authenticate with the Lit Network repeatedly without manual human signing. This is handled via **Session Signatures**.

### **6.1 Session Sigs vs. Auth Sigs**

* **Auth Sig:** A "Master Key" signature (e.g., from the Controller's EthWallet). It proves ownership but is static and high-risk if exposed.  
* **Session Sig:** A "Temporary Key" generated for a specific session. The client generates a random Ed25519 keypair locally. It then asks the Lit Network (or the Controller wallet) to *sign* a capability object authorizing this specific Ed25519 key to act on behalf of the PKP for a limited time (e.g., 24 hours).

The agent workflow is:

1. Agent starts up.  
2. Agent uses the Controller Key (stored in secure env) to generate an **AuthSig**.  
3. Agent uses the AuthSig to request **Session Sigs** from the Lit Network.  
4. Agent uses the Session Sigs for all subsequent requests (executing Lit Actions).

### **6.2 Implementation: Executing the Action**

This code snippet shows how the Python agent uses the PKP and the Lit Action code to execute the logic defined in Section 5.3.

Python

from lit\_python\_sdk import connect  
import json

\#... (Assume client is connected and PKP info is available)...

\# 1\. Define the Transaction to Sign  
\# In a real app, use web3.py to build a transaction and hash it.  
\# Here we use a dummy hash.  
to\_sign\_hex \= "0xadb20420bde8cda6771249188817098fca8ccf8eef2120a31e3f64f5812026bf"  
\# Convert to integer array for Lit Action compatibility  
hex\_str \= to\_sign\_hex\[2:\] if to\_sign\_hex.startswith("0x") else to\_sign\_hex  
to\_sign\_arr \= \[int(hex\_str\[i:i+2\], 16) for i in range(0, len(hex\_str), 2)\]

\# 2\. Generate Session Signatures for Execution  
\# We request two capabilities:   
\#   1\. Ability to execute Lit Actions  
\#   2\. Ability for the PKP to sign data (pkp-signing)  
session\_sigs\_result \= client.get\_session\_sigs(  
    chain="ethereum",  
    expiration=(datetime.now(timezone.utc) \+ timedelta(minutes=10)).strftime("%Y-%m-%dT%H:%M:%SZ"),  
    resource\_ability\_requests=\[  
        {  
            "resource": {  
                "resource": "\*",   
                "resourcePrefix": "lit-pkp",  
            },  
            "ability": "pkp-signing",  
        },  
        {  
            "resource": {  
                "resource": "\*",   
                "resourcePrefix": "lit-litaction",  
            },  
            "ability": "lit-action-execution",  
        }  
    \]  
)

\# 3\. Execute the Action  
print("Executing Lit Action...")  
result \= client.execute\_js(  
    code=litActionCode, \# From 5.3, or use 'ipfsId': 'Qm...'  
    js\_params={  
        "toSign": to\_sign\_arr,  
        "publicKey": pkp\_info\["publicKey"\],  
        "minTemp": 60 \# We can pass dynamic params too  
    },  
    session\_sigs=session\_sigs\_result  
)

\# 4\. Handle the Result  
response \= result\["response"\]  
print("Raw Response:", response)

\# If signature was returned (JSON string), parse it  
if isinstance(response, str) and "r" in response:  
    sig\_data \= json.loads(response)  
    print("Signature R:", sig\_data\["r"\])  
    print("Signature S:", sig\_data\["s"\])  
    print("Signature V:", sig\_data\["v"\])  
    print("Agent successfully authorized and signed the transaction\!")  
else:  
    print("Agent declined to sign:", response)

11

## **7\. Economic Modeling: Capacity Credits**

Unlike typical blockchain interactions where users pay gas per transaction, Lit Protocol utilizes a **Capacity Credits** model for network usage. This is akin to a SaaS subscription for compute.

### **7.1 The Requests Per Second (RPS) Model**

Agents consume **Requests Per Second (RPS)**. Every time the agent asks the network to run a Lit Action or sign a message, it counts against a quota.

* **Payment Token:** tstLPX (Testnet) or Bridged Assets (Mainnet).  
* **Mechanism:** You mint an NFT that represents a reserved capacity (e.g., 10 requests/second) for a specific duration (e.g., 30 days).  
* **Delegation:** The Controller Wallet mints the NFT (paying the fee) and then **delegates** the credit to the PKP. This allows the PKP to "spend" the credit without owning the NFT itself.

### **7.2 Cost Expectations**

Pricing is dynamic and network-dependent.

* **Free Tier (Testnet):** The Datil-Test network is free but requires tstLPX from the faucet to mint credits. Limits are generous for development.  
* **Mainnet Pricing:** Pricing is established by the node operators and market demand. It is generally structured to be predictable for high-volume agents (e.g., $X/month for Y RPS) rather than volatile gas spikes.  
* **Gas vs. Compute:** Note that Capacity Credits pay for *Lit Network Compute* (the TEE execution). They do *not* pay for the gas on the destination chain (e.g., Ethereum Mainnet). The PKP address must still hold ETH to pay for the transaction it signs.14

### **7.3 Implementation: Buying and Delegating Credits**

This step is mandatory for mainnet deployment and recommended for testnet to avoid rate limits.

Python

\# Pseudo-code representation of Contracts SDK logic via Python wrapper  
\# 1\. Mint Capacity Credit NFT  
\# We reserve 80 requests per kilosecond (approx 0.08 requests/ms)  
credit\_mint\_tx \= client.contracts.mint\_capacity\_credits\_nft(  
    requests\_per\_kilosecond=80,   
    days\_until\_expiration=7  
)  
token\_id \= credit\_mint\_tx\["tokenId"\]

\# 2\. Delegate to the Agent (PKP)  
\# We allow the PKP address to use this credit.  
delegation\_tx \= client.contracts.create\_capacity\_delegation\_auth\_sig(  
    uses='unlimited',  
    d\_app\_owner\_wallet=client.wallet, \# Controller Wallet  
    capacity\_token\_id=token\_id,  
    delegatee\_addresses=\[pkp\_info\['ethAddress'\]\]  
)

print(f"Capacity Credit {token\_id} delegated to Agent {pkp\_info\['ethAddress'\]}")

9

## **8\. Advanced Agent Architectures and Integrations**

The PKP setup described above is the foundation. To build truly sophisticated autonomous agents, developers can integrate Lit Protocol with broader AI frameworks.

### **8.1 Integration with Agent Frameworks (LangChain, Letta)**

Recent developments in AI orchestration, such as **Letta** (formerly MemGPT) and **LangChain**, allow agents to maintain state and memory. Lit Protocol serves as the "Wallet Tool" for these frameworks.

* **The Architecture:**  
  1. **Brain:** A Letta agent running in Python/Node manages the context window, user intent, and decision making.19  
  2. **Tool:** A custom "Lit Tool" is defined. When the Letta agent decides "I need to swap tokens," it calls the lit\_tool.sign\_transaction() function.  
  3. **Execution:** The lit\_tool uses the lit-python-sdk to invoke the Lit Action. The Lit Action verifies the transaction matches the agent's safety policy (e.g., "Swap amount \< 10% of portfolio") before signing.

This decoupling is powerful: The AI (LLM) can "hallucinate" or make mistakes, but the Lit Action (TEE Code) acts as a hard cryptographic guardrail that prevents the AI from draining the wallet.20

### **8.2 Cross-Chain and Wrapped Keys**

While PKPs natively support ECDSA (Ethereum, Bitcoin, Cosmos), Lit has introduced **Wrapped Keys**. This allows generating keys for non-ECDSA chains (like Solana's Ed25519) inside the TEE. The private key is generated, encrypted, and stored. When the agent needs to sign a Solana transaction, the key is decrypted momentarily inside the TEE, used to sign, and wiped from memory. This enables a single Python agent to manage a multi-chain portfolio natively.5

## **9\. Security Best Practices for Autonomous Agents**

1. **Immutable Policies:** Always use IPFS CIDs for Lit Actions in production. Never allow an agent to execute arbitrary strings of code provided at runtime.  
2. **Scope Minimization:** When generating Session Sigs, request *only* the scopes needed (e.g., if the agent only needs to sign, do not grant SignAnything, grant LitActionExecution for a specific action).  
3. **Rate Limiting:** Use Capacity Credits to hard-cap the agent's activity. If an agent goes rogue (e.g., an infinite loop of trading), the Capacity Credit limit acts as a circuit breaker.  
4. **Monitoring:** Implement listeners for the agent's address on-chain. If suspicious activity occurs, the Controller Wallet (holding the NFT) should immediately transfer the PKP NFT to a "Burner" address or update the Auth Methods to revoke the compromised agent's access.

## **10\. Conclusion**

Lit Protocol transforms the autonomous agent from a security liability into a sovereign economic actor. By moving key management from the application layer to a decentralized network of TEEs, developers can deploy Python-based agents that are resilient, non-custodial, and governed by immutable logic.

The migration to the Datil mainnet and the maturity of the lit-python-sdk provide a production-ready substrate for this new economy. Whether integrating with simple cron jobs or complex Letta-based cognitive architectures, the steps outlined in this guide—Minting, Permissioning, Action Writing, and Delegating—form the standardized protocol for giving AI the power to transact securely in the human world.

**Final Checklist for Developers:**

1. \[ \] Install lit-python-sdk.  
2. \[ \] Fund Controller Wallet with tstLPX (Datil-Test) or Bridged Assets (Datil).  
3. \[ \] Mint PKP and record tokenId.  
4. \[ \] Write Lit Action, test locally, then upload to IPFS.  
5. \[ \] Mint Capacity Credits and delegate to PKP.  
6. \[ \] Deploy Python Agent with Session Sig generation logic.

#### **Works cited**

1. Programmable Key Pairs (PKPs): Empowering Web3 Applications ..., accessed December 21, 2025, [https://medium.com/@umar361farooq/programmable-key-pairs-pkps-empowering-web3-applications-with-lit-protocol-9cc0b5ffa005](https://medium.com/@umar361farooq/programmable-key-pairs-pkps-empowering-web3-applications-with-lit-protocol-9cc0b5ffa005)  
2. Unveiling the Magic of LIT Network: Decoding Programmable Key ..., accessed December 21, 2025, [https://medium.com/@black\_Diamond/unveiling-the-magic-of-lit-network-decoding-programmable-key-pairs-for-the-digital-age-8b94184b7779](https://medium.com/@black_Diamond/unveiling-the-magic-of-lit-network-decoding-programmable-key-pairs-for-the-digital-age-8b94184b7779)  
3. Lit Protocol Price USD, LITKEY Price Live Charts, Market Cap & News, accessed December 21, 2025, [https://www.bitget.com/price/lit-protocol-%F0%9F%94%91](https://www.bitget.com/price/lit-protocol-%F0%9F%94%91)  
4. Signing within a Lit Action \- Lit Protocol, accessed December 21, 2025, [https://developer.litprotocol.com/sdk/serverless-signing/combining-signatures](https://developer.litprotocol.com/sdk/serverless-signing/combining-signatures)  
5. Signing a Transaction \- Wrapped Keys \- Lit Protocol, accessed December 21, 2025, [https://developer.litprotocol.com/user-wallets/wrapped-keys/sign-transaction](https://developer.litprotocol.com/user-wallets/wrapped-keys/sign-transaction)  
6. Mint via Contracts | Lit Protocol, accessed December 21, 2025, [https://developer.litprotocol.com/user-wallets/pkps/minting/via-contracts](https://developer.litprotocol.com/user-wallets/pkps/minting/via-contracts)  
7. Chronicle Yellowstone \- Lit Protocol, accessed December 21, 2025, [https://developer.litprotocol.com/connecting-to-a-lit-network/lit-blockchains/chronicle-yellowstone](https://developer.litprotocol.com/connecting-to-a-lit-network/lit-blockchains/chronicle-yellowstone)  
8. Mainnets \- Lit Protocol, accessed December 21, 2025, [https://developer.litprotocol.com/connecting-to-a-lit-network/mainnets](https://developer.litprotocol.com/connecting-to-a-lit-network/mainnets)  
9. Capacity Credits \- Lit Protocol, accessed December 21, 2025, [https://developer.litprotocol.com/sdk/capacity-credits](https://developer.litprotocol.com/sdk/capacity-credits)  
10. Connecting to a Lit Network \- Lit Protocol, accessed December 21, 2025, [https://developer.litprotocol.com/connecting-to-a-lit-network/connecting](https://developer.litprotocol.com/connecting-to-a-lit-network/connecting)  
11. lit-python-sdk \- PyPI, accessed December 21, 2025, [https://pypi.org/project/lit-python-sdk/](https://pypi.org/project/lit-python-sdk/)  
12. The Lit Protocol SDK provides developers with a framework ... \- GitHub, accessed December 21, 2025, [https://github.com/LIT-Protocol/js-sdk](https://github.com/LIT-Protocol/js-sdk)  
13. Introducing the Lit Python SDK \- Spark by Lit Protocol, accessed December 21, 2025, [https://spark.litprotocol.com/lit-python-sdk/](https://spark.litprotocol.com/lit-python-sdk/)  
14. Paying for Usage of Lit \- Lit Protocol, accessed December 21, 2025, [https://developer.litprotocol.com/paying-for-lit/overview](https://developer.litprotocol.com/paying-for-lit/overview)  
15. Fetching Data from the Web within a Lit Action \- Lit Protocol, accessed December 21, 2025, [https://developer.litprotocol.com/sdk/serverless-signing/fetch](https://developer.litprotocol.com/sdk/serverless-signing/fetch)  
16. Execute Javascript \- Lit Protocol Documentation, accessed December 21, 2025, [https://litprotocol.mintlify.app/sdk/auth-context-consumption/execute-js](https://litprotocol.mintlify.app/sdk/auth-context-consumption/execute-js)  
17. Lit Protocol: Towards Autonomy on the User-Owned Web \- Medium, accessed December 21, 2025, [https://medium.com/1kxnetwork/lit-protocol-towards-autonomy-on-the-user-owned-web-ad84905210a9](https://medium.com/1kxnetwork/lit-protocol-towards-autonomy-on-the-user-owned-web-ad84905210a9)  
18. Capacity Credits \- Lit Protocol, accessed December 21, 2025, [https://developer.litprotocol.com/paying-for-lit/capacity-credits](https://developer.litprotocol.com/paying-for-lit/capacity-credits)  
19. Developer quickstart \- Letta Docs, accessed December 21, 2025, [https://docs.letta.com/quickstart/](https://docs.letta.com/quickstart/)  
20. Define and customize tools \- Letta Docs, accessed December 21, 2025, [https://docs.letta.com/guides/agents/custom-tools/](https://docs.letta.com/guides/agents/custom-tools/)  
21. letta-ai/letta: Letta is the platform for building stateful agents \- GitHub, accessed December 21, 2025, [https://github.com/letta-ai/letta](https://github.com/letta-ai/letta)